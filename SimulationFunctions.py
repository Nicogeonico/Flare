# -*- coding: utf-8 -*-
"""
Created on Sun Oct 17 14:49:25 2021

@author: CoburnS

Functions for simulating data

"""

import time
import warnings
import copy
import os
import glob
import matplotlib.pyplot as plt
from scipy import interpolate as intrp
# import allantools as ad
import pickle as pkl
import numpy as np
import pandas as pd
import matplotlib as mpl

from pathlib import Path

curdir = r"C:\git\static_code"
os.chdir(curdir)

# find_package("pldspectrapy")
os.chdir(r"C:\git\pldspectrapy")
import pldspectrapy as pld
import td_support as td
import pldspectrapy.pldhapi as pldhapi
import hapi as realhapi

os.chdir(curdir)

import scale_model_testing as smt

#######################################################
#   Supress UserWarning generated by fitting
#######################################################
warnings.filterwarnings("ignore", category=UserWarning)
#######################################################
#######################################################

#######################################################
#   Plot formatting
#######################################################
mpl.rcParams["pdf.fonttype"] = 42
mpl.rcParams["ps.fonttype"] = 42
mpl.rcParams["font.family"] = "Arial"
plt.rcParams.update({"figure.autolayout": True, "lines.linewidth": 0.8})
plt.rcParams.update({"mathtext.default": "regular"})
#######################################################
#######################################################


def generate_sim_dictionary(
    data_dir=r"C:\git\linelists_CH4",
    data_file="H2O",
    molec_name="h2O",
    molec_id=1,
    molec_fract=0.01,
    sim_range=[6007, 6155],
    pressure=1.0,
    temperature=300.0,
    pathlength=1e5,
):
    """
    Generates output dictionaries taht can then be used to run the  'generate_spectrum function'
    - Should be able to configure multiple molecules -> data_file and MolecInfo
    fields in dictionaries are lists; all other fields in output dictionaries
    will be used as common inputs for all molecules

    Parameters
    ----------
    data_dir : str, optional
        File path to database files. The default is r"C:\git\linelists_CH4".
    data_file : str, optional
        Name of specific database file. The default is "H2O".
    molec_name : str, optional
        Name of molecule. The default is "h2O".
    molec_id : int, optional
        HITRAN molecular ID. The default is 1 (for H2O).
    molec_fract : float, optional
        Mole fraction to model. The default is 0.01.
    sim_range : list of floats, optional
        Wavenumber bounds for simulation. The default is [6007, 6155].
    pressure : float, optional
        Model pressure. The default is 1.0.
    temperature : float, optional
        Model temperature. The default is 300.0.
    pathlength : float, optional
        Model pathlength. The default is 1e5.

    Returns
    -------
    FileInfo : dict
        Dictionary of file information.
    MolecInfo : dict
        Dictionary of molecule information.
    EnvInfo : dict
        Dictionary of environmental information.



    """

    FileInfo = {}
    MolecInfo = {}
    EnvInfo = {}

    FileInfo["data_dir"] = data_dir
    FileInfo["data_file"] = []
    FileInfo["data_file"].append(data_file)

    MolecInfo["molec_name"] = []
    MolecInfo["molec_id"] = []
    MolecInfo["molec_iso"] = []
    MolecInfo["molec_fract"] = []

    MolecInfo["molec_name"].append(molec_name)
    MolecInfo["molec_id"].append(molec_id)
    MolecInfo["molec_iso"].append(int(1))
    MolecInfo["molec_fract"].append(molec_fract)

    EnvInfo["sim_range"] = sim_range
    EnvInfo["spec_res"] = 200e6
    EnvInfo["pressure"] = pressure
    EnvInfo["temperature"] = temperature
    EnvInfo["pathlength"] = pathlength

    return FileInfo, MolecInfo, EnvInfo


def generate_spectrum(FileInfo, MolecInfo, EnvInfo, index=0, skip_db=False, plot=False):
    """


    Parameters
    ----------
    FileInfo : dict
        Dictionary of file information
        Fields: 'data_dir'; 'data_file'
    MolecInfo : dict
        Dictionary of molecule information
        Fields: 'molec_name'; 'molec_id'; 'molec_iso'; 'molec_fract'
    EnvInfo : dict
        Dictionary of environmental information
        Fields: 'sim_range'; 'spec_res'; 'pressure'; 'temperature'; 'pathlength'
    index : int, optional
        If passing multiple molecules, sets which to simulate. The default is 0.
    skip_db : bool, optional
        Can skip loading the databases (if db_begin() hase already been run for
        the line list directory. The default is False.
    plot : bool, optional
        Create a label plot of the model. The default is False.

    Returns
    -------
    nu : TYPE
        DESCRIPTION.
    coefs : TYPE
        DESCRIPTION.
    t_delta : TYPE
        DESCRIPTION.

    """

    data_dir = FileInfo["data_dir"]
    data_file = FileInfo["data_file"][index]

    molec_name = MolecInfo["molec_name"][index]
    molec_id = MolecInfo["molec_id"][index]
    molec_iso = MolecInfo["molec_iso"][index]
    molec_fract = MolecInfo["molec_fract"][index]

    sim_range = EnvInfo["sim_range"]
    spec_res = EnvInfo["spec_res"]
    pressure_val = EnvInfo["pressure"]
    temperature_val = EnvInfo["temperature"]
    pathlength = EnvInfo["pathlength"]

    if not skip_db:
        pldhapi.db_begin(data_dir)

    wvn_resolution = ((2.99792458e8 / spec_res) * 100) ** -1
    wvn_pnts = np.round((sim_range[1] - sim_range[0]) / wvn_resolution) + 1

    wvn_arr = sim_range[0] + np.arange(wvn_pnts) * wvn_resolution

    print("Calculating spectrum for " + molec_name)

    t0 = time.time()

    nu, coefs = pldhapi.absorptionCoefficient_Voigt(
        ((int(molec_id), int(molec_iso), molec_fract),),
        data_file,
        HITRAN_units=False,
        OmegaGrid=wvn_arr,
        Environment={
            "p": pressure_val,
            "T": temperature_val,
        },
        Diluent={
            "self": molec_fract,
            "air": (1 - molec_fract),
        },
    )
    coefs *= realhapi.abundance(
        int(molec_id), int(molec_iso)
    )  # assume natural abundance
    coefs *= pathlength

    t_delta = time.time() - t0

    # print("Total simulation %.2f seconds" % (time.time() - t0))

    if plot:
        plt.figure()
        plt.plot(nu, coefs, label=MolecInfo["molec_name"][index])
        plt.legend().set_draggable(True)
        plt.ylabel("Absorbance", fontsize=15)
        plt.xlabel("Wavenumber ($cm^{-1}$)", fontsize=15)
        plt.tick_params(axis="both", labelsize=13)

    return nu, coefs, t_delta


def set_up_models():

    t0 = time.time()

    # set up HAPI information
    linedir = r"C:\git\linelists"
    # linedir = r"C:\development\inputs\spectrapy\linelists_CH4"
    pld.db_begin(linedir)  # point HAPI (nested function in fit) to linelist file

    # set up data saving parameters
    savedata = 0
    savepath = r"I:\My Drive\misc spectroscopy\H2S\OSSE"
    savename = "osse_tests.txt"
    savename_td = "osse_tests_fits.txt"

    # set up some environmental conditions
    sim_temperature = 300
    sim_pressure = 0.91
    sim_pathlength = 2.2e5

    band_fit = [5800, 6300]  # fit range

    sim_multiple = True
    use_td_models = False

    if sim_multiple:
        # multi-species simulation
        sim_molec = ["CH4_HIT08", "CH4_HIT08"]  # , "H2S"]
        sim_molecid = [6, 6]  # , 31]
        sim_moleciso = [1, 1]  # , 1]
        sim_molef = [8e-4, 8e-4]  # ,
        #     50e-6,
        # ]
        sim_temperature = [300, 900]  # , 300]
        sim_pressure = [0.82, 0.82]  # , 0.91]
        sim_pathlength = [20, 20]  # , 5e5]
        # sim_molec = ["N2O", "NH3", "CH4"]
        # sim_molecid = [4, 11, 6]
        # sim_moleciso = [1, 1, 1]
        # sim_molef = [2e-6, 2e-6, 2e-6]
        # sim_temperature = [300, 300, 300]
        # sim_pressure = [0.91, 0.91, 0.91]
        # sim_pathlength = [4e5, 4e5, 4e5]

        if use_td_models:
            # set up some fitting parameters for later
            mod1, pars1 = td.spectra_single_lmfit("h2o")
            pars1["h2omol_id"].value = sim_molecid[0]
            pars1["h2omolefraction"].set(
                value=sim_molef[0], vary=True
            )  # (molefraction)
            pars1["h2opressure"].set(
                value=sim_pressure, vary=False
            )  # (atm), 20201125 Exp
            pars1["h2otemperature"].set(value=sim_temperature, vary=False)  # (K)
            pars1["h2opathlength"].set(value=sim_pathlength, vary=False)  # (cm)
            pars1["h2oshift"].vary = False  # (cm-1, but always float)

            mod2, pars2 = td.spectra_single_lmfit("ch4")
            pars2["ch4mol_id"].value = sim_molecid[1]
            pars2["ch4molefraction"].set(
                value=sim_molef[1], vary=True
            )  # (molefraction)
            pars2["ch4pressure"].set(
                value=sim_pressure, vary=False
            )  # (atm), 20201125 Exp
            pars2["ch4temperature"].set(value=sim_temperature, vary=False)  # (K)
            pars2["ch4pathlength"].set(value=sim_pathlength, vary=False)  # (cm)
            pars2["ch4shift"].vary = False  # (cm-1, but always float)

            mod3, pars3 = td.spectra_single_lmfit("co2")
            pars3["co2mol_id"].value = sim_molecid[2]
            pars3["co2molefraction"].set(
                value=sim_molef[2], vary=True
            )  # (molefraction)
            pars3["co2pressure"].set(
                value=sim_pressure, vary=False
            )  # (atm), 20201125 Exp
            pars3["co2temperature"].set(value=sim_temperature, vary=False)  # (K)
            pars3["co2pathlength"].set(value=sim_pathlength, vary=False)  # (cm)
            pars3["co2shift"].vary = False  # (cm-1, but always float)

            modfull = mod1 + mod2 + mod3
            pars1.update(pars2)
            pars1.update(pars3)

        wvn_resolution = ((2.99792458e8 / 200e6) * 100) ** -1
        wvn_pnts = np.round((band_fit[1] - band_fit[0]) / wvn_resolution) + 1

        wvn_arr = band_fit[0] + np.arange(wvn_pnts) * wvn_resolution

        model_total = [0] * (len(wvn_arr))
        models = {}

        for idx, sim in enumerate(sim_molec):
            molec = sim_molec[idx]
            molecid = sim_molecid[idx]
            molef = sim_molef[idx]
            moleciso = sim_moleciso[idx]
            temperature = sim_temperature[idx]
            pressure = sim_pressure[idx]
            pathlength = sim_pathlength[idx]

            nu, model = pldhapi.absorptionCoefficient_Voigt(
                ((int(molecid), int(moleciso), molef),),
                molec,
                HITRAN_units=False,
                OmegaGrid=wvn_arr,
                Environment={"p": pressure, "T": temperature},
                Diluent={"self": molef, "air": (1 - molef)},
            )
            model *= realhapi.abundance(
                int(molecid), int(moleciso)
            )  # assume natural abundance
            model *= pathlength

            models[idx] = model

            if idx != 3:
                print("Adding model number", idx)
                model_total += model

        print("Runtime %d seconds" % (time.time() - t0))

        output_dict = {}
        output_dict["wvn_arr"] = wvn_arr
        output_dict["model_total"] = model_total
        output_dict["models"] = models

        return output_dict

    else:
        # single-species simulation
        # sim_molec = ["H2O"]
        # sim_molecid = [1]
        # sim_molef = [0.01]
        # model_molef = 0.01
        sim_molec = ["H2O_HITEMP"]
        sim_molecid = [1]
        sim_molef = [0.15]
        model_molef = 0.15

        # set up some fitting parameters for later
        # mod, pars = td.spectra_single_lmfit("h2o")
        # pars["h2omol_id"].value = int(sim_molecid[0])
        # pars["h2omolefraction"].set(value=sim_molef[0], vary=True)  # (molefraction)
        # pars["h2opressure"].set(value=sim_pressure, vary=False)  # (atm)
        # pars["h2otemperature"].set(value=sim_temperature, vary=True)  # (K)
        # pars["h2opathlength"].set(value=sim_pathlength, vary=False)  # (cm)
        # pars["h2oshift"].vary = False  # (cm-1, but always float)
        # modfull = mod

        # set up some fitting parameters for later
        mod, pars = td.spectra_single_lmfit("ch4")
        pars["ch4mol_id"].value = int(sim_molecid[0])
        pars["ch4molefraction"].set(value=sim_molef[0], vary=True)  # (molefraction)
        pars["ch4pressure"].set(value=sim_pressure, vary=False)  # (atm)
        pars["ch4temperature"].set(value=sim_temperature, vary=True)  # (K)
        pars["ch4pathlength"].set(value=sim_pathlength, vary=False)  # (cm)
        pars["ch4shift"].vary = False  # (cm-1, but always float)
        modfull = mod

        # set up scale_model parameters
        scale_mod1, scale_params1 = smt.setup_scale_model(prefix="h2s")
        # scale_params1["h2smolefraction"].set(value=sim_molef[0], vary=True)
        scale_params1["h2smolefraction"].set(value=model_molef, vary=True)
        scale_params1["h2spathlength"].set(value=sim_pathlength, vary=False)  # (cm)
        full_scale_model = scale_mod1

    # wvn_resolution = ((2.99792458e8 / 200e6) * 100) ** -1
    # wvn_pnts = np.round((band_fit[1] - band_fit[0]) / wvn_resolution) + 1

    # wvn_arr = band_fit[0] + np.arange(wvn_pnts) * wvn_resolution

    # nu, model1 = hapi.absorptionCoefficient_Voigt(
    #     ((sim_molecid[0], int(1), model_molef),),
    #     sim_molec[0],
    #     HITRAN_units=False,
    #     OmegaGrid=wvn_arr,
    #     Environment={"p": sim_pressure, "T": sim_temperature},
    #     Diluent={"self": model_molef, "air": (1 - model_molef)},
    # )

    # model1 *= sim_pathlength

    # # plt.figure()
    # plt.plot(nu, model1)


def generic_simulate():

    t0 = time.time()

    # set up HAPI information
    linedir = r"C:\git\linelists_HITRAN_1_5um"
    pld.db_begin(linedir)  # point HAPI (nested function in fit) to linelist file

    # set up some environmental conditions
    sim_molec = ["CH4", "CO2", "H2O", "SO2", "NO", "NO2", "H2CO"]
    sim_molecid = [6, 2, 1, 9, 8, 10, 20]
    sim_moleciso = [1, 1, 1, 1, 1, 1, 1]
    sim_molef = [2e-6, 450e-6, 0.01, 15e-9, 300e-9, 3e-9, 30e-9]
    sim_temperature = [300, 300, 300, 300, 300, 300, 300]
    sim_pressure = [1, 1, 1, 1, 1, 1, 1]
    sim_pathlength = [1e5, 1e5, 1e5, 1e5, 1e5, 1e5, 1e5]

    band_fit = [2000, 7000]  # fit range

    # Create wavenumber array for region of interest
    wvn_resolution = ((2.99792458e8 / 200e6) * 100) ** -1
    wvn_pnts = np.round((band_fit[1] - band_fit[0]) / wvn_resolution) + 1

    wvn_arr = band_fit[0] + np.arange(wvn_pnts) * wvn_resolution

    model_total0 = [0] * (len(wvn_arr))
    model_total1 = [0] * (len(wvn_arr))
    models = {}

    plt.figure()

    for idx in range(len(sim_molec)):
        molec = sim_molec[idx]
        molecid = sim_molecid[idx]
        molef = sim_molef[idx]
        moleciso = sim_moleciso[idx]
        temperature = sim_temperature[idx]
        pressure = sim_pressure[idx]
        pathlength = sim_pathlength[idx]

        print(
            "Simulating",
            molec,
            " with ",
            molef,
            " concentration for ",
            temperature,
            " K , ",
            pressure,
            " atm, and ",
            pathlength,
            " cm pathlength",
        )

        nu, model = pldhapi.absorptionCoefficient_Voigt(
            ((int(molecid), int(moleciso), molef),),
            molec,
            HITRAN_units=False,
            OmegaGrid=wvn_arr,
            Environment={"p": pressure, "T": temperature},
            Diluent={"self": molef, "air": (1 - molef)},
        )
        model *= realhapi.abundance(
            int(molecid), int(moleciso)
        )  # assume natural abundance
        model *= pathlength

        models[idx] = model

        model_total0 += model

        plt.plot(wvn_arr, model)

    # model_total0 = models[1] + models[2]
    # model_total1 = models[4] + models[5]

    # plt.figure()
    # plt.plot(wvn_arr, model_total0, wvn_arr, model_total1)

    print("Runtime %d seconds" % (time.time() - t0))

    return wvn_arr, model_total0, models


def est_linreg(v1, v2, n1, n2):
    b = (n2 * v1 - n1 * v2) / (v1 - v2)
    m = (n1 - b) / v1
    return m, b


def weighted_noise(data, weights, max_noise=0.005, min_noise=0.001):
    """
    Generates a noisy spectrum based on transmission weighting

    Parameters
    ----------
    data : array
        Input array to which noise will be added.
    weights : array
        Weight array for scaling the noise values
    max_noise : float, optional
        Maximum noise value to use. The default is 0.005.
    min_noise : float, optional
        Minimum noise value to use. The default is 0.001.

    Returns
    -------
    noisy_data

    """
    noisy_data = []

    m, b = est_linreg(
        np.max(weights[57000:118000]),
        np.min(weights[57000:118000]),
        min_noise,
        max_noise,
    )

    for idx, val in enumerate(data):
        weight = (weights[idx] * m) + b
        new_val = val + np.random.normal(0, weight)
        noisy_data.append(new_val)

    return noisy_data


def addnoise(data, noise_std=0.001):
    """
    Function for generating random noise on an input signal.

    INPUTS:
        data - input data signal
        noise_std - standard deviation of the noise to add

    OUTPUTS:
        noisy_data - input data + the added noise

    """

    noise = np.random.normal(0, noise_std, len(data))

    noisy_data = data + noise

    return noisy_data


def addnoise_linear(data, start_std=0.001, final_std=0.005):
    """
    Function for generating random noise on an input signal. The resulting noise
    has a linearly increasing structure.

    INPUTS:
        data - input data signal
        start_std - starting value for the standard deviation of the noise
        final_std - final value for the standard deviation of the noise

    OUTPUTS:
        noisy_data - input data + the added noise

    """

    index = np.arange(len(data))
    ramp = index * ((final_std - start_std) / len(data))
    noise = np.random.normal(0, start_std + ramp, len(data))

    noisy_data = data + noise

    return noisy_data


def addbaseline_sinusoid(data, amplitude=0.0001, num_osc=0.5, phase_shift=0):
    """
    Function for superimposing a sinusoidal structure on top of input data.

    INPUTS:
        data - input data signal
        amplitude - +/- amplitude of sin wave
        num_osc - number of waves in the sin function

    OUTPUTS:
        bl_data - input data + sinusoidal structure

    """

    index = np.arange(len(data)) + (len(data) * phase_shift)
    sin_idx = ((num_osc * 2 * np.pi) / len(data)) * index
    sin_arr = amplitude * np.sin(sin_idx)

    bl_data = data + sin_arr

    return bl_data


def simulate_only():

    t0 = time.time()
    # Create wavenumber array for region of interest
    wvn_start = 5880
    wvn_stop = 6155
    wvn_resolution = ((2.99792458e8 / 25e6) * 100) ** -1
    wvn_pnts = np.round((wvn_stop - wvn_start) / wvn_resolution) + 1

    wvn_arr = wvn_start + np.arange(wvn_pnts) * wvn_resolution

    model_total = [0] * (len(wvn_arr))
    models = {}

    for idx in range(len(sim_molec)):
        molec = sim_molec[idx]
        molecid = sim_molecid[idx]
        molef = sim_molef[idx]

        nu, model = hapi.absorptionCoefficient_Voigt(
            ((int(molecid), int(1), molef),),
            molec,
            HITRAN_units=False,
            OmegaGrid=wvn_arr,
            Environment={"p": sim_pressure, "T": sim_temperature},
            Diluent={"self": molef, "air": (1 - molef)},
        )
        model *= hapi.abundance(int(molecid), int(1))  # assume natural abundance
        model *= sim_pathlength

        models[molec] = model
        model_total += model

    # noise_val = 0.0001
    # noisy_model = addnoise_linear(
    #     model_total, start_std=noise_val, final_std=(noise_val * 1)
    # )

    noisy_model = model_total[:]

    print("Runtime %d seconds" % (time.time() - t0))

    return wvn_arr, noisy_model, models


def simulate_and_fit(noise_val=0.001, scale_fit=False):

    # noise_val = 0.0001
    # scale_fit = True

    load_sim = 0

    if load_sim:
        # Data repository
        d = r"H:\SERDP\WindCline\Experiments\20201125_WindClineExperiments\_processing\CFD_processing"
        # Update the data file name -> should match the save name from Simulations.py
        datafile = "Scan5_models_3.txt"
        transmatrix = np.loadtxt(os.path.join(d, datafile))

        col = 10
        try:
            model_load = transmatrix[:, col]
        except:
            model_load = transmatrix[:]

        wvnfile = "testdata_wvn.txt"
        wvn_arr = np.loadtxt(os.path.join(d, wvnfile))

    else:

        # Create wavenumber array for region of interest
        wvn_start = 6130
        wvn_stop = 6380
        wvn_resolution = ((2.99792458e8 / 200e6) * 100) ** -1
        wvn_pnts = np.round((wvn_stop - wvn_start) / wvn_resolution) + 1

        wvn_arr = wvn_start + np.arange(wvn_pnts) * wvn_resolution

    start_pnt, stop_pnt = td.bandwidth_select_td(wvn_arr, band_fit)

    # final x-value array
    x_wvn = wvn_arr[start_pnt:stop_pnt]

    # Create the baseline, etalon, and weight information
    bl = 25
    etalons = []  # narrow range (Paul's range)
    # etalons = [[800, 920]]  # narrow range (Paul's range)
    weight = td.weight_func(len(x_wvn), bl, etalons)

    if load_sim:

        model_fd = model_load[start_pnt:stop_pnt]

    else:
        model_total = [0] * ((len(x_wvn) - 1) * 2)

        for idx in range(len(sim_molec)):
            molec = sim_molec[idx]
            molecid = sim_molecid[idx]
            molef = sim_molef[idx]

            model = td.spectra_single(
                x_wvn,
                molecid,
                1,
                molef,
                sim_pressure,
                sim_temperature,
                sim_pathlength,
                0,
                name=molec,
            )

            model_total += model

        model_fd = np.fft.rfft(model_total)

    # Large baseline structure
    # bl_model = addbaseline_sinusoid(model_fd, amplitude=0.2, num_osc=0.75)
    # # Fast etalon structure - strong
    # bl_model = addbaseline_sinusoid(
    #     bl_model, amplitude=0.01, num_osc=250, phase_shift=0.25
    # )
    # # Less fast etalon structure - weak
    # bl_model = addbaseline_sinusoid(bl_model, amplitude=0.005, num_osc=75)
    bl_model = model_fd[:]
    # bl_model = [0] * (len(model_fd))

    # if scale_fit is True:
    #     model_fd /= sim_pathlength

    num_iterations = 30

    t0_0 = time.time()

    for idx in range(num_iterations):

        t0 = time.time()

        noisy_model = addnoise_linear(
            bl_model, start_std=noise_val, final_std=(noise_val * 1)
        )
        new_model = np.fft.irfft(noisy_model)

        if scale_fit is False:
            print("Running standard fit")
            Fit = modfull.fit(
                new_model,
                xx=x_wvn,
                params=pars1,
                weights=weight,
                name=sim_molec,
            )

        else:
            print("Running scale_fit")

            (nu, coefs) = pld.absorptionCoefficient_Voigt(
                ((sim_molecid[0], 1, model_molef),),
                sim_molec[0],
                HITRAN_units=False,
                OmegaGrid=x_wvn,
                Environment={
                    "p": sim_pressure,
                    "T": sim_temperature,
                },
                Diluent={
                    "self": model_molef,
                    "air": (1 - model_molef),
                },
            )
            coefs *= hapi.abundance(sim_molecid[0], 1)

            Fit = scale_mod1.fit(
                new_model,
                model_h2s=coefs,
                params=scale_params1,
                weights=weight,
            )

        # Pull time domain fit data
        y_datai = Fit.data
        fit_datai = Fit.best_fit
        weight = Fit.weights

        plot_fit_td = 0
        plot_fit_freq = 0

        if plot_fit_td:
            # And plot time domain
            plt.figure()
            plt.plot(y_datai)
            plt.plot(fit_datai)
            plt.plot(y_datai - fit_datai)
            plt.plot(weight)

        if plot_fit_freq:
            # Pull frequency domain fit data
            data_lessbl = np.real(
                np.fft.rfft(y_datai - (1 - weight) * (y_datai - fit_datai))
            )
            model = np.real(np.fft.rfft(fit_datai))
            residual = data_lessbl - model

            # And plot frequency domain
            fig, axs = plt.subplots(2, 1, sharex="col")
            axs[0].plot(x_wvn, data_lessbl, x_wvn, model)
            axs[1].plot(x_wvn, residual)
            # axs[0].set_ylabel('Absorbance'); #axs[0].legend(['data','fit'])
            # axs[1].set_ylabel('Residual'); axs[1].set_xlabel('Wavenumber ($cm^{-1}$)')

        if savedata:
            # Create an output string with file information
            outinfo = "====================================================" + "\n"
            outinfo += "[[Data Info]]\n"
            outinfo += "\tFit region\t\t\t = " + str(band_fit) + "\n"
            outinfo += "\tBaseline\t\t\t = " + str(bl) + "\n"
            outinfo += "\tEtalons\t\t\t\t = " + str(etalons) + "\n"
            outinfo += "\tNoise level\t\t\t = " + str(noise_val) + "\n"

            # DY - In order to save fit results to a textfile I use the following lines:
            f = open(os.path.join(savepath, savename), "a")
            f.write(outinfo)
            f.write(Fit.fit_report() + "\n")
            # f.write('===================================================='+'\n')
            f.close()

            # Save the time domain fit arrays
            # fit_outdata_td = np.array([y_datai, fit_datai, weight])
            # fit_outdata_td = fit_outdata_td.T
            # np.savetxt(
            #     os.path.join(savepath, savename_td + "_" + str(idx) + ".txt"),
            #     fit_outdata_td,
            #     delimiter="\t",
            # )

        print("Runtime %d seconds" % (time.time() - t0))

    # f = open(os.path.join(savepath, savename), "a")
    # f.write("====================================================" + "\n")
    # f.close()

    print("Total runtime %d seconds" % (time.time() - t0_0))

    return y_datai, fit_datai, x_wvn


def simulate_and_fit_loop(sim_conc=1e-6, noise_val=0.001, scale_fit=False):

    linelist_dir = r"C:\git\linelists"
    pld.db_begin(linelist_dir)

    # sim_conc = 1000e-9
    # noise_val = 0.0000001
    # scale_fit = False
    savedata = False

    sim_molec = ["H2S_trunc"]
    # sim_molec = ["H2O"]
    sim_molecid = [31]
    sim_molef = [sim_conc]
    sim_pressure = 0.9
    sim_temperature = 300
    sim_pathlength = 4e5
    model_molef = 10e-9

    # set up some fitting parameters for later
    mod, pars = td.spectra_single_lmfit("h2s")
    pars["h2smol_id"].value = 31
    pars["h2smolefraction"].set(value=sim_molef[0], vary=True)  # (molefraction)
    pars["h2spressure"].set(value=sim_pressure, vary=False)  # (atm), 20201125 Exp
    pars["h2stemperature"].set(value=sim_temperature, vary=False)  # (K)
    pars["h2spathlength"].set(value=sim_pathlength, vary=False)  # (cm)
    pars["h2sshift"].vary = False  # (cm-1, but always float)
    modfull = mod

    # set up scale_model parameters
    scale_mod1, scale_params1 = smt.setup_scale_model(prefix="h2s")
    # scale_params1["h2smolefraction"].set(value=sim_molef[0], vary=True)
    scale_params1["h2smolefraction"].set(value=model_molef, vary=True)
    scale_params1["h2spathlength"].set(value=sim_pathlength, vary=False)  # (cm)

    # Create wavenumber array for region of interest
    band_fit = [6130, 6380]
    wvn_start = band_fit[0]
    wvn_stop = band_fit[1]
    wvn_resolution = ((2.99792458e8 / 200e6) * 100) ** -1
    wvn_pnts = np.round((wvn_stop - wvn_start) / wvn_resolution) + 1

    wvn_arr = wvn_start + np.arange(wvn_pnts) * wvn_resolution

    start_pnt, stop_pnt = td.bandwidth_select_td(wvn_arr, band_fit)

    # final x-value array
    x_wvn = wvn_arr[start_pnt:stop_pnt]

    # Create the baseline, etalon, and weight information
    bl = 25
    etalons = []  # narrow range (Paul's range)
    # etalons = [[800, 920]]  # narrow range (Paul's range)
    weight = td.weight_func(len(x_wvn), bl, etalons)

    model_total = [0] * ((len(x_wvn) - 1) * 2)

    for idx in range(len(sim_molec)):
        molec = sim_molec[idx]
        molecid = sim_molecid[idx]
        molef = sim_molef[idx]

        model = td.spectra_single(
            x_wvn,
            molecid,
            1,
            molef,
            sim_pressure,
            sim_temperature,
            sim_pathlength,
            0,
            name=molec,
        )

        model_total += model

    model_fd = np.fft.rfft(model_total)

    # Large baseline structure
    # bl_model = addbaseline_sinusoid(model_fd, amplitude=0.2, num_osc=0.75)
    # # Fast etalon structure - strong
    # bl_model = addbaseline_sinusoid(
    #     bl_model, amplitude=0.01, num_osc=250, phase_shift=0.25
    # )
    # # Less fast etalon structure - weak
    # bl_model = addbaseline_sinusoid(bl_model, amplitude=0.005, num_osc=75)
    bl_model = model_fd[:]
    # bl_model = [0] * (len(model_fd))

    # if scale_fit is True:
    #     model_fd /= sim_pathlength

    num_iterations = 1

    t0_0 = time.time()

    for idx in range(num_iterations):

        t0 = time.time()

        noisy_model = addnoise_linear(
            bl_model, start_std=noise_val, final_std=(noise_val * 1)
        )
        new_model = np.fft.irfft(noisy_model)

        if not scale_fit:
            print("Running standard fit")
            Fit = modfull.fit(
                new_model, xx=x_wvn, params=pars, weights=weight, name=sim_molec
            )

        else:
            print("Running scale_fit")

            (nu, coefs) = pld.absorptionCoefficient_Voigt(
                ((sim_molecid[0], 1, model_molef),),
                sim_molec[0],
                HITRAN_units=False,
                OmegaGrid=x_wvn,
                Environment={
                    "p": sim_pressure,
                    "T": sim_temperature,
                },
                Diluent={
                    "self": model_molef,
                    "air": (1 - model_molef),
                },
            )
            coefs *= realhapi.adundance(sim_molecid[0], 1)

            Fit = scale_mod1.fit(
                new_model,
                model_h2s=coefs,
                params=scale_params1,
                weights=weight,
            )

        # # Pull time domain fit data
        y_datai = Fit.data
        fit_datai = Fit.best_fit
        weight = Fit.weights

        # plot_fit_td = 0
        # plot_fit_freq = 0

        if plot_fit_td:
            # And plot time domain
            plt.figure()
            plt.plot(y_datai)
            plt.plot(fit_datai)
            plt.plot(y_datai - fit_datai)
            plt.plot(weight)

        if plot_fit_freq:
            # Pull frequency domain fit data
            data_lessbl = np.real(
                np.fft.rfft(y_datai - (1 - weight) * (y_datai - fit_datai))
            )
            model = np.real(np.fft.rfft(fit_datai))
            residual = data_lessbl - model

            # And plot frequency domain
            fig, axs = plt.subplots(2, 1, sharex="col")
            axs[0].plot(x_wvn, data_lessbl, x_wvn, model)
            axs[1].plot(x_wvn, residual)
        #     # axs[0].set_ylabel('Absorbance'); #axs[0].legend(['data','fit'])
        #     # axs[1].set_ylabel('Residual'); axs[1].set_xlabel('Wavenumber ($cm^{-1}$)')

    #     if savedata:
    #         # Create an output string with file information
    #         outinfo = "====================================================" + "\n"
    #         outinfo += "[[Data Info]]\n"
    #         outinfo += "\tFit region\t\t\t = " + str(band_fit) + "\n"
    #         outinfo += "\tBaseline\t\t\t = " + str(bl) + "\n"
    #         outinfo += "\tEtalons\t\t\t\t = " + str(etalons) + "\n"
    #         outinfo += "\tNoise level\t\t\t = " + str(noise_val) + "\n"
    #         outinfo += "\tInitial concentration\t\t\t = " + str(model_molef) + "\n"
    #         outinfo += "\tSimulated concentration\t\t\t = " + str(sim_conc) + "\n"

    #         # DY - In order to save fit results to a textfile I use the following lines:
    #         f = open(os.path.join(savepath, savename), "a")
    #         f.write(outinfo)
    #         f.write(Fit.fit_report() + "\n")
    #         # f.write('===================================================='+'\n')
    #         f.close()

    #         # Save the time domain fit arrays
    #         # fit_outdata_td = np.array([y_datai, fit_datai, weight])
    #         # fit_outdata_td = fit_outdata_td.T
    #         # np.savetxt(
    #         #     os.path.join(savepath, savename_td + "_" + str(idx) + ".txt"),
    #         #     fit_outdata_td,
    #         #     delimiter="\t",
    #         # )

    #     print("Runtime %d seconds" % (time.time() - t0))

    # f = open(os.path.join(savepath, savename), "a")
    # f.write("====================================================" + "\n")
    # f.close()

    print("Total runtime %d seconds" % (time.time() - t0_0))

    # return y_datai, fit_datai, x_wvn


def simulate_and_fit_loop_scale():

    t0 = time.time()

    linedir = r"C:\git\linelists_CO2"
    pld.db_begin(linedir)  # point HAPI (nested function in fit) to linelist file

    moleclist = ["CO2"]  # , "CH4", "H2O", "H2S"]
    noiselist = [0.003]
    # noiselist = [0.008, 0.02, 0.1, 0.3]

    for cntr1, molecule in enumerate(moleclist):

        for cntr2, noise_val in enumerate(noiselist):
            # molecule = "CO2"
            # noise_val = 0.02

            sim_pathlength = 2e5
            sim_pressure = 0.95
            sim_temperature = 300

            if molecule == "H2S":
                sim_molec = ["H2S"]
                sim_molecid = [31]
                sim_molef = [30e-9]
                model_molef = 10e-9
                band_fit = [6170, 6385]

                # set up scale_model parameters
                scale_mod1, scale_params1 = smt.setup_scale_model(prefix="h2s")
                scale_params1["h2smolefraction"].set(value=model_molef, vary=True)
                scale_params1["h2spathlength"].set(
                    value=sim_pathlength, vary=False
                )  # (cm)

            elif molecule == "H2O":
                sim_molec = ["H2O"]
                sim_molecid = [1]
                sim_molef = [0.01]
                model_molef = 0.005
                band_fit = [6007, 6155]

                # set up scale_model parameters
                scale_mod1, scale_params1 = smt.setup_scale_model(prefix="h2o")
                scale_params1["h2omolefraction"].set(value=model_molef, vary=True)
                scale_params1["h2opathlength"].set(
                    value=sim_pathlength, vary=False
                )  # (cm)

            elif molecule == "CO2":
                sim_molec = ["CO2"]
                sim_molecid = [2]
                sim_molef = [450e-6]
                model_molef = 500e-6
                band_fit = [6300, 6374]

                # set up scale_model parameters
                scale_mod1, scale_params1 = smt.setup_scale_model(prefix="co2")
                scale_params1["co2molefraction"].set(value=model_molef, vary=True)
                scale_params1["co2pathlength"].set(
                    value=sim_pathlength, vary=False
                )  # (cm)

            elif molecule == "CH4":
                sim_molec = ["CH4_HIT08"]
                sim_molecid = [6]
                sim_molef = [2.5e-6]
                model_molef = 2e-6
                band_fit = [6007, 6155]

                # set up scale_model parameters
                scale_mod1, scale_params1 = smt.setup_scale_model(prefix="ch4")
                scale_params1["ch4molefraction"].set(value=model_molef, vary=True)
                scale_params1["ch4pathlength"].set(
                    value=sim_pathlength, vary=False
                )  # (cm)

            else:
                raise Exception("You gotta choose an allowable molecule ding dong")

            td_residual = np.loadtxt(os.path.join(r"c:\git", r"td_residual.txt"))
            td_residual_wvn = np.loadtxt(
                os.path.join(r"c:\git", r"td_residual_wvn.txt")
            )

            fd_residual = np.real(np.fft.rfft(td_residual))

            # Create wavenumber array for region of interest
            wvn_start = 5900
            wvn_stop = 6375
            wvn_resolution = ((2.99792458e8 / 200e6) * 100) ** -1
            wvn_pnts = np.round((wvn_stop - wvn_start) / wvn_resolution) + 1

            wvn_arr = wvn_start + np.arange(wvn_pnts) * wvn_resolution

            start_pnt, stop_pnt = td.bandwidth_select_td(wvn_arr, band_fit)

            # final x-value array
            x_wvn = wvn_arr[start_pnt:stop_pnt]

            # Create the baseline, etalon, and weight information
            bl = 115
            etalons = [[440, 550]]
            # etalons = [[800, 920]]
            weight = td.weight_func(len(x_wvn), bl, etalons)

            # model_total = [0] * ((len(x_wvn) - 1) * 2)

            molec = sim_molec[0]
            molecid = sim_molecid[0]
            molef = sim_molef[0]

            model = td.spectra_single(
                x_wvn,
                molecid,
                1,
                molef,
                sim_pressure,
                sim_temperature,
                sim_pathlength,
                0,
                name=molec,
            )

            model_fd = np.real(np.fft.rfft(model))

            use_measured_res = 0

            if use_measured_res == 0:

                # Large baseline structure
                bl_model = addbaseline_sinusoid(model_fd, amplitude=0.2, num_osc=0.75)
                # # Fast etalon structure - strong
                bl_model = addbaseline_sinusoid(
                    bl_model, amplitude=0.01, num_osc=250, phase_shift=0.25
                )
                # # Less fast etalon structure - weak
                # bl_model = addbaseline_sinusoid(bl_model, amplitude=0.005, num_osc=75)

            else:

                intrp_f = intrp.interp1d(
                    td_residual_wvn, fd_residual, kind="nearest-up"
                )
                fd_residual_new = intrp_f(x_wvn)
                # fd_residual_new = np.interp(x_wvn, td_residual_wvn, fd_residual)

                smoothing_length = 30
                kernal = np.ones(smoothing_length) / smoothing_length
                fd_residual_smth = np.convolve(fd_residual_new, kernal, mode="same")
                fd_residual_smth[0:9] = fd_residual_smth[11]
                fd_residual_smth[
                    len(fd_residual_smth) - 10 : len(fd_residual_smth)
                ] = fd_residual_smth[len(fd_residual_smth) - 12]

                td_residual_new = np.fft.irfft(fd_residual_new)
                # td_residual_new[55:400] = 0
                # td_residual_new[555:60500] = 0
                # fd_residual_new = np.real(np.fft.rfft(td_residual_new))

                new_model = td_residual_new + model

                bl_model = np.real(np.fft.rfft(new_model))

            # bl_model = [0] * (len(model_fd))

            # if scale_fit is True:
            #     model_fd /= sim_pathlength

            num_iterations = 7500

            act_avg_time = 0.5
            data_arr = []
            act_time_series = []
            noise_arr = []

            low_noise_model = [0] * len(np.fft.irfft(bl_model))

            data_dict = {}

            for idx in range(num_iterations):

                print(
                    "Running iteration",
                    idx,
                    " of",
                    num_iterations,
                    " for",
                    molecule,
                    " with ",
                    str(noise_val),
                    " noise",
                )

                act_time_series.append((idx + 1) * act_avg_time)

                noisy_model = addnoise_linear(
                    bl_model, start_std=noise_val * 5, final_std=(noise_val)
                )

                new_model = np.fft.irfft(noisy_model)

                low_noise_model += new_model
                avg_model = low_noise_model / (idx + 1)

                if idx == 0:
                    (nu, coefs) = pld.absorptionCoefficient_Voigt(
                        ((sim_molecid[0], 1, model_molef),),
                        sim_molec[0],
                        HITRAN_units=False,
                        OmegaGrid=x_wvn,
                        Environment={
                            "p": sim_pressure,
                            "T": sim_temperature,
                        },
                        Diluent={
                            "self": model_molef,
                            "air": (1 - model_molef),
                        },
                    )
                    coefs *= hapi.abundance(sim_molecid[0], 1)

                    # coefs *= sim_pathlength

                if molecule == "H2S":
                    Fit = scale_mod1.fit(
                        new_model,
                        model_h2s=coefs,
                        params=scale_params1,
                        weights=weight,
                    )

                    data_arr.append(Fit.best_values["h2smolefraction"] * model_molef)

                    Fit = scale_mod1.fit(
                        avg_model,
                        model_h2s=coefs,
                        params=scale_params1,
                        weights=weight,
                    )

                elif molecule == "H2O":
                    Fit = scale_mod1.fit(
                        new_model,
                        model_h2o=coefs,
                        params=scale_params1,
                        weights=weight,
                    )

                    data_arr.append(Fit.best_values["h2omolefraction"] * model_molef)

                    Fit = scale_mod1.fit(
                        avg_model,
                        model_h2o=coefs,
                        params=scale_params1,
                        weights=weight,
                    )

                elif molecule == "CO2":
                    Fit = scale_mod1.fit(
                        new_model,
                        model_co2=coefs,
                        params=scale_params1,
                        weights=weight,
                    )

                    data_arr.append(Fit.best_values["co2molefraction"] * model_molef)

                    Fit = scale_mod1.fit(
                        avg_model,
                        model_co2=coefs,
                        params=scale_params1,
                        weights=weight,
                    )

                elif molecule == "CH4":
                    Fit = scale_mod1.fit(
                        new_model,
                        model_ch4=coefs,
                        params=scale_params1,
                        weights=weight,
                    )

                    data_arr.append(Fit.best_values["ch4molefraction"] * model_molef)

                    Fit = scale_mod1.fit(
                        avg_model,
                        model_ch4=coefs,
                        params=scale_params1,
                        weights=weight,
                    )

                # Pull time domain fit data
                y_datai = Fit.data
                fit_datai = Fit.best_fit
                weight = Fit.weights

                # Pull frequency domain fit data
                data_lessbl = np.real(
                    np.fft.rfft(y_datai - (1 - weight) * (y_datai - fit_datai))
                )
                model = np.real(np.fft.rfft(fit_datai))
                residual = data_lessbl - model
                res_subset = residual[
                    int((len(residual) / 2) - 250) : int((len(residual) / 2) + 250)
                ]
                noise_calc = np.std(res_subset)
                noise_arr.append(noise_calc)

            (tau_out, adev, adeverr, n) = ad.adev(
                data_arr,
                rate=(act_avg_time ** -1),
                data_type="freq",
                taus="all",
            )

            ad_results = np.array([tau_out, adev, adeverr, n])
            ad_data = np.array([data_arr, act_time_series, noise_arr])

            data_dict["AD data"] = ad_data
            data_dict["AD results"] = ad_results

            outname = "out_" + molecule + "_" + str(cntr2) + ".pkl"
            output_file = os.path.join(
                r"I:\My Drive\misc spectroscopy\lpt_sensitivity", outname
            )

            with open(output_file, "wb") as f:
                pkl.dump(data_dict, f)

    # # Pull time domain fit data
    # y_datai = Fit.data
    # fit_datai = Fit.best_fit
    # weight = Fit.weights

    # # Pull frequency domain fit data
    # data_lessbl = np.real(np.fft.rfft(y_datai - (1 - weight) * (y_datai - fit_datai)))
    # model = np.real(np.fft.rfft(fit_datai))
    # residual = data_lessbl - model

    # plt.figure()
    # plt.plot(y_datai)
    # plt.plot(fit_datai)
    # plt.plot(y_datai - fit_datai)

    # fig, axs = plt.subplots(2, 1, sharex="col")
    # axs[0].plot(x_wvn, data_lessbl, x_wvn, model)
    # axs[1].plot(x_wvn, residual)

    t1 = time.time()

    print("Runtime = ", (t1 - t0))

    # return y_datai, fit_datai, x_wvn


def simulate_fit_multiple():

    t0 = time.time()

    linedir = r"C:\git\linelists_CO2"
    pld.db_begin(linedir)  # point HAPI (nested function in fit) to linelist file

    moleclist = ["H2O", "CO2", "CH4_HIT08"]
    moleflist = [0.01, 450e-6, 2.5e-6]
    molecidlist = [1, 2, 6]
    sim_moleflist = [0.01, 300e-6, 2e-6]

    sim_pathlength = 4e5
    sim_pressure = 0.95
    sim_temperature = 300

    band_fit = [6175, 6270]

    # Band range for noise characterization
    band_noise = [6193.6, 6194.6]

    # set up scale_model parameters

    # set up some fitting parameters for later
    mod1, pars1 = td.spectra_single_lmfit("h2o")
    pars1["h2omol_id"].value = 1
    pars1["h2omolefraction"].set(value=sim_moleflist[0], vary=True)  # (molefraction)
    pars1["h2opressure"].set(value=sim_pressure, vary=False)  # (atm), 20201125 Exp
    pars1["h2otemperature"].set(value=sim_temperature, vary=False)  # (K)
    pars1["h2opathlength"].set(value=sim_pathlength, vary=False)  # (cm)
    pars1["h2oshift"].vary = False  # (cm-1, but always float)

    # set up some fitting parameters for later
    mod2, pars2 = td.spectra_single_lmfit("co2")
    pars2["co2mol_id"].value = 2
    pars2["co2molefraction"].set(value=sim_moleflist[1], vary=True)  # (molefraction)
    pars2["co2pressure"].set(value=sim_pressure, vary=False)  # (atm), 20201125 Exp
    pars2["co2temperature"].set(value=sim_temperature, vary=False)  # (K)
    pars2["co2pathlength"].set(value=sim_pathlength, vary=False)  # (cm)
    pars2["co2shift"].vary = False  # (cm-1, but always float)

    # set up some fitting parameters for later
    mod3, pars3 = td.spectra_single_lmfit("ch4")
    pars3["ch4mol_id"].value = 6
    pars3["ch4molefraction"].set(value=sim_moleflist[2], vary=True)  # (molefraction)
    pars3["ch4pressure"].set(value=sim_pressure, vary=False)  # (atm), 20201125 Exp
    pars3["ch4temperature"].set(value=sim_temperature, vary=False)  # (K)
    pars3["ch4pathlength"].set(value=sim_pathlength, vary=False)  # (cm)
    pars3["ch4shift"].vary = False  # (cm-1, but always float)

    modfull = mod1 + mod2 + mod3
    all_params = copy.deepcopy(pars1)
    all_params.update(pars2)
    all_params.update(pars3)

    # set up scale_model parameters
    scale_mod1, scale_params1 = smt.setup_scale_model(prefix="h2o")
    scale_params1["h2omolefraction"].set(value=sim_moleflist[0], vary=True)
    scale_params1["h2opathlength"].set(value=sim_pathlength, vary=False)  # (cm)

    # set up scale_model parameters
    scale_mod2, scale_params2 = smt.setup_scale_model(prefix="co2")
    scale_params2["co2molefraction"].set(value=sim_moleflist[1], vary=True)
    scale_params2["co2pathlength"].set(value=sim_pathlength, vary=False)  # (cm)

    # set up scale_model parameters
    scale_mod3, scale_params3 = smt.setup_scale_model(prefix="ch4")
    scale_params3["ch4molefraction"].set(value=sim_moleflist[2], vary=True)
    scale_params3["ch4pathlength"].set(value=sim_pathlength, vary=False)  # (cm)

    full_scale_mod = scale_mod1 + scale_mod2 + scale_mod3
    all_scaling_params = copy.deepcopy(scale_params1)
    all_scaling_params.update(scale_params2)
    all_scaling_params.update(scale_params3)

    # Create wavenumber array for region of interest
    wvn_start = 6000
    wvn_stop = 6395
    wvn_resolution = ((2.99792458e8 / 200e6) * 100) ** -1
    wvn_pnts = np.round((wvn_stop - wvn_start) / wvn_resolution) + 1

    wvn_arr = wvn_start + np.arange(wvn_pnts) * wvn_resolution

    start_pnt, stop_pnt = td.bandwidth_select_td(wvn_arr, band_fit)

    # final x-value array
    x_wvn = wvn_arr[start_pnt:stop_pnt]

    noise_start = np.searchsorted(x_wvn, band_noise[0], "left") - 1
    noise_stop = np.searchsorted(x_wvn, band_noise[1], "right")

    # Create the baseline, etalon, and weight information
    bl = 100
    etalons = [[475, 530]]
    # etalons = [[800, 920]]
    weight = td.weight_func(len(x_wvn), bl, etalons)

    model_total = [0] * ((len(x_wvn) - 1) * 2)

    for idx, molec in enumerate(moleclist):

        model = td.spectra_single(
            x_wvn,
            molecidlist[idx],
            1,
            moleflist[idx],
            sim_pressure,
            sim_temperature,
            sim_pathlength,
            0,
            name=molec,
        )

        model_total += model

    model_fd = np.real(np.fft.rfft(model_total))

    (h2o_nu, h2o_coefs) = pld.absorptionCoefficient_Voigt(
        ((molecidlist[0], 1, sim_moleflist[0]),),
        moleclist[0],
        HITRAN_units=False,
        OmegaGrid=x_wvn,
        Environment={
            "p": sim_pressure,
            "T": sim_temperature,
        },
        Diluent={
            "self": sim_moleflist[0],
            "air": (1 - sim_moleflist[0]),
        },
    )
    h2o_coefs *= hapi.abundance(int(molecidlist[0]), 1)

    (co2_nu, co2_coefs) = pld.absorptionCoefficient_Voigt(
        ((molecidlist[1], 1, sim_moleflist[1]),),
        moleclist[1],
        HITRAN_units=False,
        OmegaGrid=x_wvn,
        Environment={
            "p": sim_pressure,
            "T": sim_temperature,
        },
        Diluent={
            "self": sim_moleflist[1],
            "air": (1 - sim_moleflist[1]),
        },
    )
    co2_coefs *= hapi.abundance(int(molecidlist[1]), 1)

    (ch4_nu, ch4_coefs) = pld.absorptionCoefficient_Voigt(
        ((molecidlist[2], 1, sim_moleflist[2]),),
        moleclist[2],
        HITRAN_units=False,
        OmegaGrid=x_wvn,
        Environment={
            "p": sim_pressure,
            "T": sim_temperature,
        },
        Diluent={
            "self": sim_moleflist[2],
            "air": (1 - sim_moleflist[2]),
        },
    )
    ch4_coefs *= hapi.abundance(int(molecidlist[2]), 1)

    # noiselist = [0.3, 0.1, 0.08, 0.03, 0.01, 0.008, 0.003, 0.001, 0.0008]
    noiselist = [0.003]

    for cntr1, noise_val in enumerate(noiselist):

        # # Large baseline structure
        # bl_model = addbaseline_sinusoid(model_fd, amplitude=0.2, num_osc=0.75)
        # # # Fast etalon structure - strong
        # bl_model = addbaseline_sinusoid(
        #     bl_model, amplitude=0.01, num_osc=250, phase_shift=0.25
        # )
        # # Less fast etalon structure - weak
        # bl_model = addbaseline_sinusoid(bl_model, amplitude=0.005, num_osc=75)

        bl_model = copy.deepcopy(model_fd)

        num_iterations = 1

        act_avg_time = 0.5

        data_arr_h2o = []
        data_arr_co2 = []
        data_arr_ch4 = []

        data_total_arr_h2o = []
        data_total_arr_co2 = []
        data_total_arr_ch4 = []

        act_time_series = []
        noise_arr = []
        noise_total_arr = []

        low_noise_model = [0] * len(np.fft.irfft(bl_model))

        data_dict = {}

        for idx in range(num_iterations):

            print(
                "Running iteration",
                idx,
                " of",
                num_iterations,
                " for",
                str(noise_val),
                " noise",
            )

            act_time_series.append((idx + 1) * act_avg_time)

            noisy_model = addnoise_linear(
                bl_model, start_std=noise_val * 1, final_std=(noise_val)
            )

            new_model = np.fft.irfft(noisy_model)

            low_noise_model += new_model
            avg_model = low_noise_model / (idx + 1)

            # coefs *= sim_pathlength

            Fit = full_scale_mod.fit(
                new_model,
                model_co2=co2_coefs,
                model_h2o=h2o_coefs,
                model_ch4=ch4_coefs,
                params=all_scaling_params,
                weights=weight,
            )

            # Pull time domain fit data
            y_datai = Fit.data
            fit_datai = Fit.best_fit
            weight = Fit.weights

            # Pull frequency domain fit data
            data_lessbl = np.real(
                np.fft.rfft(y_datai - (1 - weight) * (y_datai - fit_datai))
            )
            model = np.real(np.fft.rfft(fit_datai))
            residual = data_lessbl - model

            res_subset = residual[noise_start:noise_stop]
            noise_calc = np.std(res_subset)
            noise_arr.append(noise_calc)

            data_arr_h2o.append(Fit.best_values["h2omolefraction"] * sim_moleflist[0])
            data_arr_co2.append(Fit.best_values["co2molefraction"] * sim_moleflist[1])
            data_arr_ch4.append(Fit.best_values["ch4molefraction"] * sim_moleflist[2])

            Fit_avg = full_scale_mod.fit(
                avg_model,
                model_co2=co2_coefs,
                model_h2o=h2o_coefs,
                model_ch4=ch4_coefs,
                params=all_scaling_params,
                weights=weight,
            )

            data_total_arr_h2o.append(
                Fit_avg.best_values["h2omolefraction"] * sim_moleflist[0]
            )
            data_total_arr_co2.append(
                Fit_avg.best_values["co2molefraction"] * sim_moleflist[1]
            )
            data_total_arr_ch4.append(
                Fit_avg.best_values["ch4molefraction"] * sim_moleflist[2]
            )

            # Pull time domain fit data
            y_datai = Fit_avg.data
            fit_datai = Fit_avg.best_fit
            weight = Fit_avg.weights

            # Pull frequency domain fit data
            data_lessbl = np.real(
                np.fft.rfft(y_datai - (1 - weight) * (y_datai - fit_datai))
            )
            model = np.real(np.fft.rfft(fit_datai))
            residual = data_lessbl - model

            res_subset = residual[noise_start:noise_stop]
            noise_calc = np.std(res_subset)
            noise_total_arr.append(noise_calc)

            # Indent here

        if len(data_arr_h2o) > 10:

            (tau_out_h2o, adev_h2o, adeverr_h2o, n_h2o) = ad.oadev(
                data_arr_h2o,
                rate=(act_avg_time ** -1),
                data_type="freq",
                taus="all",
            )

            (tau_out_co2, adev_co2, adeverr_co2, n_co2) = ad.oadev(
                data_arr_co2,
                rate=(act_avg_time ** -1),
                data_type="freq",
                taus="all",
            )

            (tau_out_ch4, adev_ch4, adeverr_ch4, n_ch4) = ad.oadev(
                data_arr_ch4,
                rate=(act_avg_time ** -1),
                data_type="freq",
                taus="all",
            )

            ad_results = np.array(
                [
                    tau_out_h2o,
                    adev_h2o,
                    adev_co2,
                    adev_ch4,
                    adeverr_h2o,
                    adeverr_co2,
                    adeverr_ch4,
                    n_h2o,
                ]
            )
            ad_data = np.array(
                [
                    data_arr_h2o,
                    data_arr_co2,
                    data_arr_ch4,
                    data_total_arr_h2o,
                    data_total_arr_co2,
                    data_total_arr_ch4,
                    act_time_series,
                    noise_arr,
                    noise_total_arr,
                ]
            )

            data_dict["AD data"] = ad_data
            data_dict["AD results"] = ad_results

            outname = "20220713_results" + str(cntr1) + ".pkl"
            output_file = os.path.join(
                r"I:\My Drive\misc spectroscopy\lpt_sensitivity", outname
            )

            with open(output_file, "wb") as f:
                pkl.dump(data_dict, f)

    # Pull time domain fit data
    y_datai = Fit.data
    fit_datai = Fit.best_fit
    weight = Fit.weights

    # Pull frequency domain fit data
    data_lessbl = np.real(np.fft.rfft(y_datai - (1 - weight) * (y_datai - fit_datai)))
    model = np.real(np.fft.rfft(fit_datai))
    residual = data_lessbl - model

    plt.figure()
    plt.plot(y_datai)
    plt.plot(fit_datai)
    plt.plot(y_datai - fit_datai)

    fig, axs = plt.subplots(2, 1, sharex="col")
    axs[0].plot(x_wvn, data_lessbl, x_wvn, model)
    axs[1].plot(x_wvn, residual)

    t1 = time.time()

    print("Runtime = ", (t1 - t0))

    return Fit, Fit_avg, y_datai, fit_datai, x_wvn


def simulate_loop():

    t0 = time.time()

    # set up some environmental conditions
    sim_temperature = 296
    sim_pressure = 0.9
    # sim_pressure = 1
    sim_pathlength = 2e5

    # band_fit = [6137, 6371]  # fit range
    sim_molec = ["CH4_HIT08"]
    sim_molecid = [6]
    sim_molef = [2e-6]
    # Create wavenumber array for region of interest
    wvn_start = 6056.8
    wvn_stop = 6057.4
    wvn_resolution = ((2.99792458e8 / 25e6) * 100) ** -1
    wvn_pnts = np.round((wvn_stop - wvn_start) / wvn_resolution) + 1

    wvn_arr = wvn_start + np.arange(wvn_pnts) * wvn_resolution

    absorbance_dict = {}
    nu_dict = {}
    lineintensity_dict = {}
    max_abs_dict = {}

    for idx, val in enumerate(range(260, 330, 1)):
        molec = sim_molec[0]
        molecid = sim_molecid[0]
        molef = sim_molef[0]

        nu, model, lineintensity = hapi.absorptionCoefficient_Voigt(
            ((int(molecid), int(1), molef),),
            molec,
            HITRAN_units=False,
            OmegaGrid=wvn_arr,
            Environment={"p": sim_pressure, "T": val},
            Diluent={"self": molef, "air": (1 - molef)},
        )
        model *= hapi.abundance(int(molecid), int(1))  # assume natural abundance
        model *= sim_pathlength

        max_ = np.max(model)

        max_abs_dict[val] = max_

        absorbance_dict[val] = model
        nu_dict[val] = nu
        # lineintensity_dict[val] = lineintensity

    print("Runtime %d seconds" % (time.time() - t0))

    return absorbance_dict, nu_dict, max_abs_dict  # , lineintensity_dict


def hot_plume_sim(savedata=False, fit_data=True, print_results=False, **kwargs):
    """
    Function to simulate and fit a hot CH4 plume on top of a background signal

    Inputs:
        savedata: bool; save results from analysis
        fit_data: bool; run the fit
        print_results: bool; prints the fit_report for each fit

        kwargs
            fit_plots: bool; plot the fit results
            savepath: string; path to results repository; required if savedata = True
            savename: string; name of output file; requride if savedata = True
            sim_dict: dictionary; simulation information
                fields: sim_molef; sim_temperature; sim_pressure; sim_pathlength
            noiselist: list; noise values to loop through; default = [0.001]
            num_its: int; number of loop iterations for each noise value; default = 30

    Outputs:
        output_dict: dictionary; contains setup info on analysis as well as results
            fields: wvn_arr; model_total; models; sim_info; out_df

    """
    t0 = time.time()

    if savedata:
        savepath = kwargs["savepath"]
        savename = kwargs["savename"]
        if (len(savepath) == 0) or (len(savename) == 0):
            raise Exception("Need to specify savepath and savename!")
        else:
            file_exists = os.path.isfile(os.path.join(savepath, savename))

    try:
        fit_plots = kwargs["fit_plots"]
    except:
        fit_plots = 0

    # set up HAPI information
    linedir = r"C:\git\linelists_CH4"
    pld.db_begin(linedir)  # point HAPI (nested function in fit) to linelist file

    base_mf = 0.5
    efficiency = 0.01
    hot_conc = base_mf * efficiency

    # set up some environmental conditions
    sim_molec = ["CH4_HIT08"]
    sim_molecid = [6, 6]
    sim_moleciso = [1, 1]

    try:
        sim_dict = kwargs["sim_dict"]
        sim_molef = sim_dict["sim_molef"]
        sim_temperature = sim_dict["sim_temperature"]
        sim_pressure = sim_dict["sim_pressure"]
        sim_pathlength = sim_dict["sim_pathlength"]
    except:
        sim_molef = [0.05, hot_conc]
        sim_temperature = [300, 900]
        sim_pressure = [0.82, 0.82]
        sim_pathlength = [10, 20]

        sim_dict = {}
        sim_dict["sim_molef"] = sim_molef
        sim_dict["sim_temperature"] = sim_temperature
        sim_dict["sim_pressure"] = sim_pressure
        sim_dict["sim_pathlength"] = sim_pathlength

    band_fit = [6007, 6155]  # fit range

    # Create wavenumber array for region of interest
    wvn_resolution = ((2.99792458e8 / 200e6) * 100) ** -1
    wvn_pnts = np.round((band_fit[1] - band_fit[0]) / wvn_resolution) + 1

    wvn_arr = band_fit[0] + np.arange(wvn_pnts) * wvn_resolution

    model_total = [0] * (len(wvn_arr))
    models = {}

    # start_pnt, stop_pnt = td.bandwidth_select_td(wvn_arr, band_fit)

    # final x-value array
    # x_wvn = wvn_arr[start_pnt:stop_pnt]

    # Create the baseline, etalon, and weight information
    bl = 25
    etalons = []  # narrow range (Paul's range)
    # etalons = [[800, 920]]  # narrow range (Paul's range)
    weight = td.weight_func(len(wvn_arr), bl, etalons)
    # set up some fitting parameters for later
    mod1, pars1 = td.spectra_single_lmfit("ch4_1")
    pars1["ch4_1mol_id"].value = 6
    pars1["ch4_1molefraction"].set(value=sim_molef[0], vary=True)  # (molefraction)
    pars1["ch4_1pressure"].set(value=sim_pressure[0], vary=False)  # (atm)
    pars1["ch4_1temperature"].set(value=280, vary=True)  # (K)
    pars1["ch4_1pathlength"].set(value=sim_pathlength[0], vary=False)  # (cm)
    pars1["ch4_1shift"].vary = False  # (cm-1, but always float)

    mod2, pars2 = td.spectra_single_lmfit("ch4_2")
    pars2["ch4_2mol_id"].value = 6
    pars2["ch4_2molefraction"].set(value=0.005, vary=True)  # (molefraction)
    pars2["ch4_2pressure"].set(value=sim_pressure[1], vary=False)  # (atm)
    pars2["ch4_2temperature"].set(value=300, vary=True)  # (K)
    pars2["ch4_2pathlength"].set(value=sim_pathlength[1], vary=False)  # (cm)
    pars2["ch4_2shift"].vary = False  # (cm-1, but always float)

    modfull = mod1 + mod2  # + mod3
    all_pars = copy.deepcopy(pars1)
    all_pars.update(pars2)

    for idx, sim in enumerate(sim_molecid):
        molec = sim_molec[0]
        molecid = sim_molecid[idx]
        molef = sim_molef[idx]
        moleciso = sim_moleciso[idx]
        temperature = sim_temperature[idx]
        pressure = sim_pressure[idx]
        pathlength = sim_pathlength[idx]

        nu, model = pldhapi.absorptionCoefficient_Voigt(
            ((int(molecid), int(moleciso), molef),),
            molec,
            HITRAN_units=False,
            OmegaGrid=wvn_arr,
            Environment={"p": pressure, "T": temperature},
            Diluent={"self": molef, "air": (1 - molef)},
        )
        model *= realhapi.abundance(
            int(molecid), int(moleciso)
        )  # assume natural abundance
        model *= pathlength

        models[idx] = model

        model_total += model

    print("Runtime %d seconds" % (time.time() - t0))

    df_cntr = 0

    output_dict = {}
    Fit_info = {}

    if fit_data:

        bl_model = model_total[:]

        try:
            noiselist = kwargs["noiselist"]
        except:
            noiselist = [0.001]

        try:
            num_its = kwargs["num_its"]
        except:
            num_its = 30

        noisy_models = {}

        for noise_cntr, noise_val in enumerate(noiselist):

            for it_cntr in range(num_its):

                t1 = time.time()

                out_df = pd.DataFrame(
                    {
                        "ch4_1_ppm": pd.Series(dtype="float"),
                        "ch4_1_uncert": pd.Series(dtype="float"),
                        "ch4_2_ppm": pd.Series(dtype="float"),
                        "ch4_2_uncert": pd.Series(dtype="float"),
                        "temperature_1": pd.Series(dtype="float"),
                        "temperature_1_uncert": pd.Series(dtype="float"),
                        "temperature_2": pd.Series(dtype="float"),
                        "temperature_2_uncert": pd.Series(dtype="float"),
                        "noise_val1": pd.Series(dtype="float"),
                        "noise_val2": pd.Series(dtype="float"),
                    }
                )

                file_exists = os.path.isfile(os.path.join(savepath, savename))

                noisy_model = addnoise_linear(
                    bl_model, start_std=noise_val * 5, final_std=(noise_val)
                )

                noisy_models[it_cntr + (noise_cntr * num_its)] = noisy_model

                new_model = np.fft.irfft(noisy_model)

                Fit = modfull.fit(
                    new_model,
                    xx=wvn_arr,
                    params=all_pars,
                    weights=weight,
                    name=sim_molec,
                )

                if fit_plots:

                    y_datai = Fit.data
                    fit_datai = Fit.best_fit
                    weight = Fit.weights

                    # And plot time domain
                    plt.figure()
                    plt.plot(y_datai)
                    plt.plot(fit_datai)
                    plt.plot(y_datai - fit_datai)
                    # plt.plot(weight)

                    # Pull frequency domain fit data
                    data_lessbl = np.real(
                        np.fft.rfft(y_datai - (1 - weight) * (y_datai - fit_datai))
                    )
                    model = np.real(np.fft.rfft(fit_datai))
                    residual = data_lessbl - model

                    # And plot frequency domain
                    fig, axs = plt.subplots(2, 1, sharex="col")
                    axs[0].plot(wvn_arr, data_lessbl, wvn_arr, model)
                    axs[1].plot(wvn_arr, residual)

                output_dict["noisy_models"] = noisy_models

                if it_cntr == 0:
                    Fit_info[noise_cntr] = (Fit, wvn_arr)

                if print_results:
                    print(Fit.fit_report())

                # Correction for water vapor to get dry mole fraction

                out_df.loc[df_cntr, "ch4_1_ppm"] = Fit.best_values["ch4_1molefraction"]
                out_df.loc[df_cntr, "ch4_1_uncert"] = td.lmfit_uc(
                    Fit, "ch4_1molefraction"
                )
                out_df.loc[df_cntr, "ch4_2_ppm"] = Fit.best_values["ch4_2molefraction"]
                out_df.loc[df_cntr, "ch4_2_uncert"] = td.lmfit_uc(
                    Fit, "ch4_2molefraction"
                )
                out_df.loc[df_cntr, "temperature_1"] = Fit.best_values[
                    "ch4_1temperature"
                ]
                out_df.loc[df_cntr, "temperature_1_uncert"] = td.lmfit_uc(
                    Fit, "ch4_1temperature"
                )
                out_df.loc[df_cntr, "temperature_2"] = Fit.best_values[
                    "ch4_2temperature"
                ]
                out_df.loc[df_cntr, "temperature_2_uncert"] = td.lmfit_uc(
                    Fit, "ch4_2temperature"
                )

                out_df.loc[df_cntr, "noise_val1"] = noise_val * 5
                out_df.loc[df_cntr, "noise_val2"] = noise_val

                df_cntr += 1

                if savedata and file_exists:
                    # Create an output string with file information
                    out_df.to_csv(
                        os.path.join(savepath, savename),
                        header=False,
                        sep="\t",
                        mode="a",
                        index=False,
                        float_format="%f",
                    )

                elif savedata and not file_exists:
                    out_df.to_csv(
                        os.path.join(savepath, savename),
                        header=True,
                        sep="\t",
                        mode="w",
                        index=False,
                        float_format="%f",
                    )

    output_dict["wvn_arr"] = wvn_arr
    output_dict["model_total"] = model_total
    output_dict["models"] = models
    output_dict["sim_info"] = sim_dict
    output_dict["out_df"] = out_df

    print("Processing time: %d seconds" % (time.time() - t0))

    if savedata:
        with open(os.path.join(savepath, "simulation_results.pkl"), "wb") as f:
            pkl.dump(output_dict, f)

    return output_dict


def outdoor_hot_plume_sim(savedata=False, fit_data=True, print_results=False, **kwargs):
    """
    Function to simulate and fit a hot CH4 plume on top of a background signal

    Inputs:
        savedata: bool; save results from analysis
        fit_data: bool; run the fit
        print_results: bool; prints the fit_report for each fit
        kwargs
            fit_plots: bool; plot the fit results
            savepath: string; path to results repository; required if savedata = True
            savename: string; name of output file; requride if savedata = True
            sim_dict: dictionary; simulation information
                fields: sim_molef; sim_temperature; sim_pressure; sim_pathlength
            noiselist: list; noise values to loop through; default = [0.001]
            num_its: int; number of loop iterations for each noise value; default = 30

    Outputs:
        output_dict: dictionary; contains setup info on analysis as well as results
            fields: wvn_arr; model_total; models; sim_info; out_df

    """
    t0 = time.time()

    # savedata = True
    # fit_data = True
    # print_results = False

    # kwargs = {}
    # kwargs["num_its"] = 1
    # kwargs["fit_plots"] = False
    # kwargs["savepath"] = r"C:\Users\CoburnS\Desktop\HotCH4"
    # kwargs["savename"] = r"outdoor_results_NIR.pkl"

    if savedata:
        try:
            savepath = kwargs["savepath"]
            savename = kwargs["savename"]
            file_exists = os.path.isfile(os.path.join(savepath, savename))
        except:
            raise Exception("Need to specify savepath and savename!")

    try:
        fit_plots = kwargs["fit_plots"]
    except:
        fit_plots = 0

    # set up HAPI information
    linedir = r"C:\git\linelists_CH4"
    pld.db_begin(linedir)  # point HAPI (nested function in fit) to linelist file

    base_mf = 0.5
    efficiency = 0.01
    hot_conc = base_mf * efficiency

    # set up some environmental conditions
    sim_molec = ["CH4_HIT08", "H2O", "CO2"]
    sim_molecid = [6, 6, 1, 2]
    sim_moleciso = [1, 1, 1, 1]

    try:
        sim_dict = kwargs["sim_dict"]
        sim_molef = sim_dict["sim_molef"]
        sim_temperature = sim_dict["sim_temperature"]
        sim_pressure = sim_dict["sim_pressure"]
        sim_pathlength = sim_dict["sim_pathlength"]
    except:
        sim_molef = [2e-6, 0.01, 0.01, 450e-6]
        sim_temperature = [300, 600, 300, 300]
        sim_pressure = [1, 1, 1, 1]
        sim_pathlength = [1e5, 100, 1e5, 1e5]

        sim_dict = {}
        sim_dict["sim_molef"] = sim_molef
        sim_dict["sim_temperature"] = sim_temperature
        sim_dict["sim_pressure"] = sim_pressure
        sim_dict["sim_pathlength"] = sim_pathlength

    band_fit = [6025, 6127]  # fit range

    # Create wavenumber array for region of interest
    wvn_resolution = ((2.99792458e8 / 200e6) * 100) ** -1
    wvn_pnts = np.round((band_fit[1] - band_fit[0]) / wvn_resolution) + 1

    wvn_arr = band_fit[0] + np.arange(wvn_pnts) * wvn_resolution

    model_total = [0] * (len(wvn_arr))
    models = {}

    # start_pnt, stop_pnt = td.bandwidth_select_td(wvn_arr, band_fit)

    # final x-value array
    # x_wvn = wvn_arr[start_pnt:stop_pnt]

    # Create the baseline, etalon, and weight information
    bl = 300
    etalons = []  # narrow range (Paul's range)
    # etalons = [[800, 920]]  # narrow range (Paul's range)
    weight = td.weight_func(len(wvn_arr), bl, etalons)
    # set up some fitting parameters for later
    mod1, pars1 = td.spectra_single_lmfit("ch4_1")
    pars1["ch4_1mol_id"].value = sim_molecid[0]
    pars1["ch4_1molefraction"].set(value=2.5e-6, vary=True)  # (molefraction)
    pars1["ch4_1pressure"].set(value=sim_pressure[0], vary=False)  # (atm)
    pars1["ch4_1temperature"].set(value=273, vary=True)  # (K)
    pars1["ch4_1pathlength"].set(value=sim_pathlength[0], vary=False)  # (cm)
    pars1["ch4_1shift"].vary = False  # (cm-1)

    mod2, pars2 = td.spectra_single_lmfit("ch4_2")
    pars2["ch4_2mol_id"].value = sim_molecid[1]
    pars2["ch4_2molefraction"].set(value=0.001, vary=True)  # (molefraction)
    pars2["ch4_2pressure"].set(value=sim_pressure[1], vary=False)  # (atm)
    pars2["ch4_2temperature"].set(value=273, vary=True)  # (K)
    pars2["ch4_2pathlength"].set(value=sim_pathlength[1], vary=False)  # (cm)
    pars2["ch4_2shift"].vary = False  # (cm-1)

    mod3, pars3 = td.spectra_single_lmfit("h2o")
    pars3["h2omol_id"].value = sim_molecid[2]
    pars3["h2omolefraction"].set(value=0.02, vary=True)  # (molefraction)
    pars3["h2opressure"].set(value=sim_pressure[2], vary=False)  # (atm)
    pars3["h2otemperature"].expr = "ch4_1temperature"  # (K)
    pars3["h2opathlength"].set(value=sim_pathlength[2], vary=False)  # (cm)
    pars3["h2oshift"].vary = False  # (cm-1)

    mod4, pars4 = td.spectra_single_lmfit("co2")
    pars4["co2mol_id"].value = sim_molecid[3]
    pars4["co2molefraction"].set(value=400e-6, vary=True)  # (molefraction)
    pars4["co2pressure"].set(value=sim_pressure[3], vary=False)  # (atm)
    pars4["co2temperature"].expr = "ch4_1temperature"  # (K)
    pars4["co2pathlength"].set(value=sim_pathlength[3], vary=False)  # (cm)
    pars4["co2shift"].vary = False  # (cm-1)

    modfull = mod1 + mod2 + mod3 + mod4
    all_pars = copy.deepcopy(pars1)
    all_pars.update(pars2)
    all_pars.update(pars3)
    all_pars.update(pars4)

    for idx, sim in enumerate(sim_molecid):
        if idx < 2:
            molec = sim_molec[0]
        else:
            molec = sim_molec[idx - 1]
        molecid = sim_molecid[idx]
        molef = sim_molef[idx]
        moleciso = sim_moleciso[idx]
        temperature = sim_temperature[idx]
        pressure = sim_pressure[idx]
        pathlength = sim_pathlength[idx]

        nu, model = pldhapi.absorptionCoefficient_Voigt(
            ((int(molecid), int(moleciso), molef),),
            molec,
            HITRAN_units=False,
            OmegaGrid=wvn_arr,
            Environment={"p": pressure, "T": temperature},
            Diluent={"self": molef, "air": (1 - molef)},
        )
        model *= realhapi.abundance(
            int(molecid), int(moleciso)
        )  # assume natural abundance
        model *= pathlength

        models[idx] = model

        model_total += model

    print("Runtime %d seconds" % (time.time() - t0))

    df_cntr = 0
    out_df_all = pd.DataFrame(
        {
            "ch4_1_ppm": pd.Series(dtype="float"),
            "ch4_1_uncert": pd.Series(dtype="float"),
            "ch4_2_ppm": pd.Series(dtype="float"),
            "ch4_2_uncert": pd.Series(dtype="float"),
            "temperature_1": pd.Series(dtype="float"),
            "temperature_1_uncert": pd.Series(dtype="float"),
            "temperature_2": pd.Series(dtype="float"),
            "temperature_2_uncert": pd.Series(dtype="float"),
            "h2o_1_percent": pd.Series(dtype="float"),
            "h2o_1_uncert": pd.Series(dtype="float"),
            "co2_1_ppm": pd.Series(dtype="float"),
            "co2_1_uncert": pd.Series(dtype="float"),
            "noise_val1": pd.Series(dtype="float"),
            "noise_val2": pd.Series(dtype="float"),
        }
    )

    output_dict = {}
    Fit_dict = {}

    if fit_data:

        bl_model = model_total[:]

        try:
            noiselist = kwargs["noiselist"]
        except:
            noiselist = [0.001]

        try:
            num_its = kwargs["num_its"]
        except:
            num_its = 30

        noisy_models = {}

        for noise_cntr, noise_val in enumerate(noiselist):

            for it_cntr in range(num_its):

                t1 = time.time()

                Fit_results = {}

                out_df = pd.DataFrame(
                    {
                        "ch4_1_ppm": pd.Series(dtype="float"),
                        "ch4_1_uncert": pd.Series(dtype="float"),
                        "ch4_2_ppm": pd.Series(dtype="float"),
                        "ch4_2_uncert": pd.Series(dtype="float"),
                        "temperature_1": pd.Series(dtype="float"),
                        "temperature_1_uncert": pd.Series(dtype="float"),
                        "temperature_2": pd.Series(dtype="float"),
                        "temperature_2_uncert": pd.Series(dtype="float"),
                        "h2o_1_percent": pd.Series(dtype="float"),
                        "h2o_1_uncert": pd.Series(dtype="float"),
                        "co2_1_ppm": pd.Series(dtype="float"),
                        "co2_1_uncert": pd.Series(dtype="float"),
                        "noise_val1": pd.Series(dtype="float"),
                        "noise_val2": pd.Series(dtype="float"),
                    }
                )

                if savedata:
                    file_exists = os.path.isfile(os.path.join(savepath, savename))

                noisy_model = addnoise_linear(
                    bl_model, start_std=noise_val * 5, final_std=(noise_val)
                )

                noisy_models[it_cntr + (noise_cntr * num_its)] = noisy_model

                new_model = np.fft.irfft(noisy_model)

                Fit = modfull.fit(
                    new_model,
                    xx=wvn_arr,
                    params=all_pars,
                    weights=weight,
                    name=sim_molec,
                )

                if fit_plots:

                    y_datai = Fit.data
                    fit_datai = Fit.best_fit
                    weight = Fit.weights

                    # And plot time domain
                    plt.figure()
                    plt.plot(y_datai)
                    plt.plot(fit_datai)
                    plt.plot(y_datai - fit_datai)
                    # plt.plot(weight)

                    # Pull frequency domain fit data
                    data_lessbl = np.real(
                        np.fft.rfft(y_datai - (1 - weight) * (y_datai - fit_datai))
                    )
                    model = np.real(np.fft.rfft(fit_datai))
                    residual = data_lessbl - model

                    # And plot frequency domain
                    fig, axs = plt.subplots(2, 1, sharex="col")
                    axs[0].plot(wvn_arr, data_lessbl, wvn_arr, model)
                    axs[1].plot(wvn_arr, residual)

                output_dict["noisy_models"] = noisy_models

                Fit_results["Fit_report"] = str(Fit.fit_report())
                Fit_results["Fit_data"] = Fit.data
                Fit_results["Fit_best_fit"] = Fit.best_fit
                Fit_results["Fit_weight"] = Fit.weights
                Fit_results["wvn"] = wvn_arr

                Fit_dict[df_cntr] = Fit_results

                if print_results:
                    print(Fit.fit_report())

                # Dataframe for saving (recreated each loop cycle)
                out_df.loc[df_cntr, "ch4_1_ppm"] = (
                    Fit.best_values["ch4_1molefraction"] * 1e6
                )
                out_df.loc[df_cntr, "ch4_1_uncert"] = (
                    td.lmfit_uc(Fit, "ch4_1molefraction") * 1e6
                )
                out_df.loc[df_cntr, "ch4_2_ppm"] = (
                    Fit.best_values["ch4_2molefraction"] * 1e6
                )
                out_df.loc[df_cntr, "ch4_2_uncert"] = (
                    td.lmfit_uc(Fit, "ch4_2molefraction") * 1e6
                )

                out_df.loc[df_cntr, "temperature_1"] = Fit.best_values[
                    "ch4_1temperature"
                ]
                out_df.loc[df_cntr, "temperature_1_uncert"] = td.lmfit_uc(
                    Fit, "ch4_1temperature"
                )
                out_df.loc[df_cntr, "temperature_2"] = Fit.best_values[
                    "ch4_2temperature"
                ]
                out_df.loc[df_cntr, "temperature_2_uncert"] = td.lmfit_uc(
                    Fit, "ch4_2temperature"
                )

                out_df.loc[df_cntr, "h2o_1_percent"] = (
                    Fit.best_values["h2omolefraction"] * 100
                )
                out_df.loc[df_cntr, "h2o_1_uncert"] = (
                    td.lmfit_uc(Fit, "h2omolefraction") * 100
                )

                out_df.loc[df_cntr, "co2_1_ppm"] = (
                    Fit.best_values["co2molefraction"] * 1e6
                )
                out_df.loc[df_cntr, "co2_1_uncert"] = (
                    td.lmfit_uc(Fit, "co2molefraction") * 1e6
                )

                out_df.loc[df_cntr, "noise_val1"] = noise_val * 5
                out_df.loc[df_cntr, "noise_val2"] = noise_val

                # Dataframe for archiving in output_dict
                out_df_all.loc[df_cntr, "ch4_1_ppm"] = (
                    Fit.best_values["ch4_1molefraction"] * 1e6
                )
                out_df_all.loc[df_cntr, "ch4_1_uncert"] = (
                    td.lmfit_uc(Fit, "ch4_1molefraction") * 1e6
                )
                out_df_all.loc[df_cntr, "ch4_2_ppm"] = (
                    Fit.best_values["ch4_2molefraction"] * 1e6
                )
                out_df_all.loc[df_cntr, "ch4_2_uncert"] = (
                    td.lmfit_uc(Fit, "ch4_2molefraction") * 1e6
                )

                out_df_all.loc[df_cntr, "temperature_1"] = Fit.best_values[
                    "ch4_1temperature"
                ]
                out_df_all.loc[df_cntr, "temperature_1_uncert"] = td.lmfit_uc(
                    Fit, "ch4_1temperature"
                )
                out_df_all.loc[df_cntr, "temperature_2"] = Fit.best_values[
                    "ch4_2temperature"
                ]
                out_df_all.loc[df_cntr, "temperature_2_uncert"] = td.lmfit_uc(
                    Fit, "ch4_2temperature"
                )

                out_df_all.loc[df_cntr, "h2o_1_percent"] = (
                    Fit.best_values["h2omolefraction"] * 100
                )
                out_df_all.loc[df_cntr, "h2o_1_uncert"] = (
                    td.lmfit_uc(Fit, "h2omolefraction") * 100
                )

                out_df_all.loc[df_cntr, "co2_1_ppm"] = (
                    Fit.best_values["co2molefraction"] * 1e6
                )
                out_df_all.loc[df_cntr, "co2_1_uncert"] = (
                    td.lmfit_uc(Fit, "co2molefraction") * 1e6
                )

                out_df_all.loc[df_cntr, "noise_val1"] = noise_val * 5
                out_df_all.loc[df_cntr, "noise_val2"] = noise_val

                df_cntr += 1

                if savedata and file_exists:
                    # Create an output string with file information
                    out_df.to_csv(
                        os.path.join(savepath, savename),
                        header=False,
                        sep="\t",
                        mode="a",
                        index=False,
                        float_format="%f",
                    )

                elif savedata and not file_exists:
                    out_df.to_csv(
                        os.path.join(savepath, savename),
                        header=True,
                        sep="\t",
                        mode="w",
                        index=False,
                        float_format="%f",
                    )

                output_dict["wvn_arr"] = wvn_arr
                output_dict["model_total"] = model_total
                output_dict["models"] = models
                output_dict["sim_info"] = sim_dict
                if fit_data:
                    output_dict["out_df"] = out_df_all
                    output_dict["Fits"] = Fit_dict

                if savedata:
                    with open(
                        os.path.join(savepath, "simulation_results.pkl"), "wb"
                    ) as f:
                        pkl.dump(output_dict, f)

                print(
                    "Finished iteration %d of %d in %d seconds"
                    % (
                        ((noise_cntr * num_its) + it_cntr),
                        (len(noiselist) * num_its),
                        (time.time() - t1),
                    )
                )

    print("Total processing time: %d seconds" % (time.time() - t0))

    return output_dict


def return_HITRAN():
    """
    Creates a dictionary of the HITRAN molecules and their molecule DCs

    Returns
    -------
    hitran_dictionary: Molecule name : molecule ID (keyword:value)

    """
    hitran_dictionary = {
        "H2O": 1,
        "CO2": 2,
        "O3": 3,
        "N2O": 4,
        "CO": 5,
        "CH4": 6,
        "O2": 7,
        "NO": 8,
        "SO2": 9,
        "NO2": 10,
        "NH3": 11,
        "HNO3": 12,
        "OH": 13,
        "HF": 14,
        "HCl": 15,
        "HBr": 16,
        "HI": 17,
        "ClO": 18,
        "OCS": 19,
        "H2CO": 20,
        "HOCl": 21,
        "N2": 22,
        "HCN": 23,
        "CH3Cl": 24,
        "H2O2": 25,
        "C2H2": 26,
        "C2H6": 27,
        "PH3": 28,
        "COF2": 29,
        "SF6": 30,
        "H2S": 31,
        "HCOOH": 32,
        "HO2": 33,
        "O": 34,
        "ClONO2": 35,
        "NO+": 36,
        "HOBr": 37,
        "C2H4": 38,
        "CH3OH": 39,
        "CH3Br": 40,
        "CH3CN": 41,
        "CF4": 42,
        "C4H2": 43,
        "HC3N": 44,
        "H2": 45,
        "CS": 46,
        "SO3": 47,
        "C2N2": 48,
        "COCl2": 49,
        "SO": 50,
        "CH3F": 51,
        "GeH4": 52,
        "CS2": 53,
        "CH3I": 54,
        "NF3": 55,
    }

    return hitran_dictionary


def fetch_hitran(file_dir, data_range):
    """
    Runs the fetch function on the HITRAN dictionary created by return_HITRAN()
    *Currently include a 'reject_list' that will exclude molecules that don't
    absorb in the MIR

    Parameters
    ----------
    file_dir : string
        Full path to repository where HITRAN data should go
    data_range : TYPE
        Wavenumber range for fetch operation

    Returns
    -------
    None.

    """

    hitran = return_HITRAN()

    realhapi.db_begin(file_dir)

    reject_list = [
        12,
        18,
        25,
        29,
        30,
        32,
        34,
        35,
        37,
        39,
        40,
        41,
        42,
        43,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
    ]

    for idx, molec in enumerate(hitran):

        if ((idx + 1) < 18) or ((idx + 1) in reject_list):
            pass
        else:
            realhapi.fetch(molec, hitran[molec], 1, data_range[0], data_range[1])


def simulate_hitran(molec_fract, sim_range, molec="", use_mir_reject=False, save=False):
    """
    Creates an absorbance model for the specified molecule; alternatively it
    will iterate through all the HITRAN molecules contained in return_HITRAN()

    Data can optionally be saved into the HITRAN repository

    Parameters
    ----------
    molec_fract : float
        Mole fraction for simulations
    sim_range : list
        Wavenumber range for simulations
    molec : string, optional
        Molecule name for simulations. The default is "" which will initiate
        iterating through the entire HITRAN list
    save : bool, optional
        Boolean  for whether or not to save the data. The default is False.

    Returns
    -------
    Models : dictionary
        Dictionry that contains:
            nu: wavenumber axis for all models
            'molecule name': absorbance for named molecule
            time: list of the simulation time for each molecule
            FileInfo: dictionary of file information used for simulations
            MolecInfo: dictionary of molecule information used for simulations
            EnvInfo: dictionaly of environmental parameters used for simulations

    """

    hitran = return_HITRAN()

    mir_reject_list = [
        12,
        18,
        25,
        29,
        30,
        32,
        34,
        35,
        37,
        39,
        40,
        41,
        42,
        43,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
    ]

    FileInfo = {}
    MolecInfo = {}
    EnvInfo = {}

    FileInfo["data_dir"] = r"C:\git\linelists_HITRAN_1_5um"

    if len(molec) > 0:
        MolecInfo["molec_name"] = [molec]
        MolecInfo["molec_id"] = list([hitran[molec]])
    else:
        MolecInfo["molec_name"] = list(hitran.keys())
        MolecInfo["molec_id"] = list(hitran[name] for idx, name in enumerate(hitran))
    MolecInfo["molec_iso"] = [1] * len(MolecInfo["molec_name"])
    MolecInfo["molec_fract"] = [molec_fract] * len(MolecInfo["molec_name"])

    EnvInfo["sim_range"] = sim_range
    EnvInfo["rep_rate"] = 200e6
    EnvInfo["pressure"] = 1
    EnvInfo["temperature"] = 323.15
    EnvInfo["pathlength"] = 1e3

    Models = {}
    timer = []

    pldhapi.db_begin(FileInfo["data_dir"])

    for idx, molec in enumerate(MolecInfo["molec_name"]):

        molec_id = MolecInfo["molec_id"][idx]

        if use_mir_reject:
            if molec_id in mir_reject_list:
                continue

        FileInfo["data_file"] = molec

        nu, coefs, t_delta = generate_spectrum(
            FileInfo, MolecInfo, EnvInfo, index=idx, skip_db=True
        )

        if idx == 0:
            Models["nu"] = nu

        Models[molec] = coefs
        timer.append(t_delta)

        print("Simulation time " + str(t_delta))

    Models["time"] = timer
    Models["FileInfo"] = FileInfo
    Models["MolecInfo"] = MolecInfo
    Models["EnvInfo"] = EnvInfo

    if save:
        with open(os.path.join(FileInfo["data_dir"], "Models.pkl"), "wb") as f:
            pkl.dump(Models, f)

    return Models


def load_Models(output_path, output_file):
    """
    Loads the dictionary created from simulate_hitran()

    Parameters
    ----------
    output_path : string
        Path to dictionary location
    output_file : string
        Dictionary file name

    Returns
    -------
    Models : dictionary
        Dictionary created from simulate_hitran()
    group_dict : dictionary
        Names of molecules in Models roughly grouped by type (highly tailored
                                                              for MIR work)

    """

    with open(os.path.join(output_path, output_file), "rb") as f:
        Models = pkl.load(f)

    group_dict = {}
    group1 = []
    group2 = []
    group3 = []
    group4 = []

    for idx, name in enumerate(Models):
        if name == "nu" or name == "time":
            continue

        if "Cl" in name or "Br" in name or "F" in name or "I" in name:
            group4.append(name)
        elif "C" in name:
            if "H" in name or "O" in name:
                group1.append(name)
            else:
                group4.append(name)
        elif "N" in name:
            group2.append(name)
        else:
            group3.append(name)

    group_dict["group1"] = group1
    group_dict["group2"] = group2
    group_dict["group3"] = group3
    group_dict["group4"] = group4

    return Models, group_dict


def plot_all_groups():
    """
    Plots models from simulate_hitran() -> different panels for the different
    groups created in load_Models()

    Returns
    -------
    None.

    """

    fig, ax = plt.subplots(4, 1, sharex=True)

    for idx, name in enumerate(Models):
        if name == "nu" or name == "time":
            continue

        if "Cl" in name or "Br" in name or "F" in name or "I" in name:
            ax[3].plot(Models["nu"], Models[name], label=name)
            group4.append(name)
        elif "C" in name:
            if "H" in name or "O" in name:
                ax[0].plot(Models["nu"], Models[name], label=name)
                group1.append(name)
            else:
                ax[3].plot(Models["nu"], Models[name], label=name)
                group4.append(name)
        elif "N" in name:
            ax[1].plot(Models["nu"], Models[name], label=name)
            group2.append(name)
        else:
            ax[2].plot(Models["nu"], Models[name], label=name)
            group3.append(name)

    ax[0].legend().set_draggable(True)
    ax[1].legend().set_draggable(True)
    ax[2].legend().set_draggable(True)
    ax[3].legend().set_draggable(True)


def plot_group(group):
    """
    Plot a single group created from simulate_hitran()

    Parameters
    ----------
    group : string
        Name of the group to be plotted

    Returns
    -------
    None.

    """
    fig, ax = plt.subplots()
    group_list = group_dict[group]
    for idx, name in enumerate(group_list):
        ax.plot(Models["nu"], Models[name], label=name)
    ax.legend().set_draggable(True)


def create_PNNL_dict(base_path, temp, sim_range, save=False):
    """
    Create a dictionary of models based on the available PNNL data

    Parameters
    ----------
    base_path : string
        File path to the PNNL database (assuming the file structure from the
                                        group SpectralDatabases)
    temp : string
        Temperate for the data to pull
        Can be: "5T", "25T", or "50T"
    sim_range : list
        Wavenumber range to extract
    save : bool, optional
        Boolean for whethor or not to save the dictionary. The default is False.

    Returns
    -------
    PNNL_Models : dictionary
        Dictionary of dataframes that contain 'nu' and 'model' for each PNNL molecule
        Dictionary keys are the PNNL molecule name; values are the dataframes

    """
    PNNL_Models = {}

    # base_path = r"C:\Users\CoburnS\Desktop\SpectralDatabases\PNNL compounds"
    output_name = "PNNL_Models.pkl"
    path_struct = base_path + "/Files/*" + temp + ".txt"
    rt_list = glob.glob(path_struct)

    # sim_range = [2000, 5000]

    for idx, fullname in enumerate(rt_list):
        data = pd.read_csv(fullname, header=None, sep="\t", names=["nu", "model"])
        data.where(
            (data["nu"] >= sim_range[0]) & (data["nu"] <= sim_range[1]),
            inplace=True,
        )
        data.dropna(inplace=True)
        data = data.set_index("nu")
        name = Path(fullname).stem
        PNNL_Models[name] = data

    if save:
        with open(os.path.join(base_path, output_name), "wb") as f:
            pkl.dump(PNNL_Models, f)

    return PNNL_Models


# if __name__ == "__main__":
#     # sim_data, sim_data_fit, model_wvn = simulate_and_fit(noise_val=0.01)
#     # wvn_arr, noisy_model = simulate_only()
#     # noise_arr = [0.001, 0.0045, 0.009, 0.01, 0.045, 0.09, 0.1, 0.15, 0.2, 0.25, 0.5]
#     conc_arr = [
#         0,
#         1e-9,
#         5e-9,
#         10e-9,
#         20e-9,
#         30e-9,
#         40e-9,
#         50e-9,
#     ]

#     noise_arr = [
#         1e-4,
#         5e-4,
#         1e-3,
#         5e-3,
#     ]

#     for idx_n, noise in enumerate(noise_arr):

#         savename = "osse_tests" + str(idx_n) + ".txt"

#         for idx_c, conc in enumerate(conc_arr):
#             simulate_and_fit_loop(sim_conc=conc, noise_val=noise)
#             simulate_and_fit_loop(sim_conc=conc, noise_val=noise)
#             simulate_and_fit_loop(sim_conc=conc, noise_val=noise)
#             simulate_and_fit_loop(sim_conc=conc, noise_val=noise)
# -*- coding: utf-8 -*-
#         for idx_c, conc in enumerate(conc_arr):
#             simulate_and_fit_loop(sim_conc=conc, noise_val=noise)
#             simulate_and_fit_loop(sim_conc=conc, noise_val=noise)
#             simulate_and_fit_loop(sim_conc=conc, noise_val=noise)
#             simulate_and_fit_loop(sim_conc=conc, noise_val=noise)
# -*- coding: utf-8 -*-
# -*- coding: utf-8 -*-
